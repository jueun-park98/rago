import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;

aspect InferParameter{

  /**
  * Saves response data names generated by random requests.
  * <p>This is an auxiliary method to distinguish saved dictionary values.</p>
  * <p>(Future work: translate this to Map or Tuple).</p>
  * @return first String part divided by <code>?</code>.
  */
  syn String ParameterObject.dictName(String dict) = dict.substring(0, dict.indexOf("?"));

  /**
  * Saves response data values generated by random requests.
  * <p>This is an auxiliary method to distinguish saved dictionary values.</p>
  * <p>(Future work: translate this to Map or Tuple).</p>
  * @return second String part divided by <code>?</code>.
  */
  syn String ParameterObject.dictValue(String dict) = dict.substring(dict.indexOf("?")+1);

  /**
  * Checks if a path has the request types <code>GET</code> and/or <code>POST</code>, and calls <code>inferUrl(String pathRef,OperationObject operationObject, List<String> dict)</code>.
  * <p>Afterwards, inferred URLs are saved in a list.</p>
  * @return The list of String representing the inferred URLs.
  */
  inh List<String> PathsObject.inferUrl(List<String> dict);
  eq OpenAPIObject.getP(int i).inferUrl(List<String> dict){
    List<String> paths = new ArrayList<>();
    PathItemObject p = getP(i).getP().pathItemObject();
    String path = getServ(0).getUrl();

    if (p.hasG())
      paths.addAll(p.getG().inferUrl(path + getP(i).getRef(), p.getG().getO(), dict));
    else if (p.hasPostOb())
      paths.addAll(p.getPostOb().inferUrl(path + getP(i).getRef(), p.getPostOb().getO(), dict));

    return paths;
  }

  /**
    * Checks which parameter types the targeted GET request has (Path or Query) and calls corresponding parameter inferrer.
    * <p>Afterwards, inferred parameters are written in the url.</p>
    * @return An URL with the inferred parameters in String.
    */
  syn List<String> Get.inferUrl(String pathRef,OperationObject operationObject, List<String> dict){
    List<String> paths = new ArrayList<>();

    for (ParameterOb o : operationObject.getPList()) {
      ParameterObject p = o.parameterObject();
      SchemaObject s = p.getSchema().schemaObject();

      // check if the parameter is in type 'path'.
      if (p.getIn().equals("path"))
        paths = p.addinfPathParameters(pathRef, dict);
        // check if the parameter is in type 'query'
      else if (p.getIn().equals("query"))
        paths = p.addinfQueryParameters(pathRef, dict);
    }

    System.out.println(paths.size() + " paths for " + pathRef + " GET request are inferred");
    return paths;
  }

  /**
    * Checks which parameter types the targeted POST request has (Path or Query) and calls corresponding parameter inferrer.
    * <p>Afterwards, inferred parameters are written in the url.</p>
    * @return An URL with the inferred parameters in String.
    */
  syn List<String> Post.inferUrl(String pathRef,OperationObject operationObject, List<String> dict){
    List<String> paths = new ArrayList<>();

    for (ParameterOb o : operationObject.getPList()) {
      ParameterObject p = o.parameterObject();
      SchemaObject s = p.getSchema().schemaObject();

      // check if the parameter is in type 'path'.
      if (p.getIn().equals("path"))
        paths = p.addinfPathParameters(pathRef, dict);
        // check if the parameter is in type 'query'
      else if (p.getIn().equals("query"))
        paths = p.addinfQueryParameters(pathRef, dict);
    }

    System.out.println(paths.size() + " paths for " + pathRef + " POST request are inferred");
    return paths;
  }

  /**
    * Checks if there are Path parameters that are saved in the dictionary and might be usable.
    * <p>Search is provided by schema names and Case-Insensitivity./p>
    * @return The list of Urls with the added Url from the dicitionary.
    */
  syn List<String> ParameterObject.addinfPathParameters(String pathRef,List<String> dict){
    List<String> paths = new ArrayList<>();
    for (String d : dict){
      // get the field which must be modified
      String pathPart = pathRef.substring(pathRef.indexOf("{"), pathRef.indexOf("}")+1);
      // case insensitive comparison of parameter name and name of inferred parameters
      if (getName().equalsIgnoreCase(d.substring(0, d.indexOf("?"))))
        // add inferred parameter in url
        paths = root().addInList(paths, pathRef.replace(pathPart, d.substring(d.indexOf("?")+1)));
    }
    return paths;
  }

  /**
    * Checks if there are Query parameters that are saved in the dictionary and might be usable.
    * <p>Search is provided by schema names and Case-Insensitivity./p>
    * @return The list of Urls with the added Url from the dicitionary.
    */
  syn List<String> ParameterObject.addinfQueryParameters(String pathRef,List<String> dict){
    List<String> paths = new ArrayList<>();
    SchemaObject s = getSchema().schemaObject();
    // check if query parameter is in type 'array'
    if (s.getType().equals("array")) {
      for (String d : dict){
        // case insensitive comparison of parameter name and name of inferred parameters
        if (getName().equalsIgnoreCase(dictName(d)) && !pathRef.contains(getName() + "=" + dictValue(d)))
          // add inferred parameter in url
          pathRef = pathRef + "&" + getName() + "=" + dictValue(d);
      }
      paths = root().addInList(paths, pathRef.replaceFirst("&", "?"));
    } else {
      for (String d : dict){
        // case insensitive comparison of parameter name and name of inferred parameters
        if (getName().equalsIgnoreCase(dictName(d)))
          // add inferred parameter in url
          paths = root().addInList(paths, pathRef + "?" + getName() + "=" + dictValue(d));
      }
    }
    return paths;
  }

  /**
    * Saves single response JSON data into the dictionary.
    * @return The list of response data (dictionary).
    */
  public List<String> OperationObject.writeDictionary(SchemaOb schema,String resp, List<String> dict)throws Exception{
    ObjectMapper mapper = new ObjectMapper();
    JsonNode respNode = mapper.readTree(resp);
    String value;

    if (schema instanceof SchemaReference) {
      for (PropertyItem p : schema.schemaObject().getPList()) {
        String infName = ((SchemaReference) schema).getRef().substring(((SchemaReference) schema).getRef().lastIndexOf("/") + 1) + p.getName();
        value = respNode.get(p.getName()).toString().startsWith("\"") &&
                respNode.get(p.getName()).toString().endsWith("\"") ?
                respNode.get(p.getName()).toString().substring(1, respNode.get(p.getName()).toString().length() - 1) : respNode.get(p.getName()).toString();

        dict = root().addInList(dict, infName + "?" + value);
        dict = root().addInList(dict, p.getName() + "?" + value);
      }
    } else {
      for (PropertyItem p : schema.schemaObject().getPList()) {
        value = respNode.get(p.getName()).toString().startsWith("\"") &&
                respNode.get(p.getName()).toString().endsWith("\"") ?
                respNode.get(p.getName()).toString().substring(1, respNode.get(p.getName()).toString().length() - 1) : respNode.get(p.getName()).toString();

        dict = root().addInList(dict, p.getName() + "?" + respNode.get(p.getName()).textValue());
      }
    }
    return dict;
  }

  /**
    * Saves array response JSON data into the dictionary.
    * @return The list of response data (dictionary).
    */
  public List<String> OperationObject.writeDictionaryWithArray(SchemaOb schema,String resp, List<String> dict)throws Exception{
    ObjectMapper mapper = new ObjectMapper();
    ArrayNode respNode = ((ArrayNode) mapper.readTree(resp));
    Iterator<JsonNode> props = respNode.elements();

    while (props.hasNext())
      dict = writeDictionary(schema.schemaObject().getI().getSchema(), props.next().toString(), dict);
    return dict;
  }

  public List<String> OpenAPIObject.addInList(List<String> list, String value){
    if( !list.contains(value) )
      list.add(value);
    return list;
  }
}